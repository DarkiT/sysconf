# Sysconf 基准测试工具

这是一个专门为 `sysconf` 配置管理库设计的综合性基准测试工具，用于评估和分析配置管理系统在各种场景下的性能表现。

## 功能特性

- **📊 全面的性能测试**: 涵盖配置初始化、环境变量绑定、配置获取、并发访问等多个维度
- **🔍 详细的性能分析**: 提供操作时间、内存分配、吞吐量等详细指标
- **📈 趋势数据生成**: 输出JSON格式的性能数据，便于长期性能趋势分析
- **💡 智能优化建议**: 基于测试结果自动生成性能优化建议
- **🎯 多场景测试**: 支持小型、中型、大型配置场景的性能对比

## 测试场景

### 1. 配置初始化性能测试
- 基础配置初始化
- 环境变量配置初始化  
- 完整功能配置初始化

### 2. 环境变量绑定性能测试
- 不同数量环境变量的绑定性能 (10, 100, 500, 1000, 5000)
- 智能大小写匹配性能
- 前缀过滤效率

### 3. 配置获取性能测试
- 简单键值获取
- 深层嵌套键值获取
- 数组元素访问
- 不存在键的处理

### 4. 并发访问性能测试
- 不同并发级别的读取性能 (1, 2, 4, 8, 16, 32 协程)
- 读写混合场景性能
- 锁竞争分析

### 5. 配置文件I/O性能测试
- 小型配置文件 (~1KB)
- 中型配置文件 (~10KB)
- 大型配置文件 (~100KB)

### 6. 内存使用测试
- 单实例内存占用
- 多实例内存使用
- 内存泄露检测

### 7. 大型配置性能测试
- 10k+ 配置项的处理性能
- 深度嵌套配置访问
- 大型配置文件解析

## 使用方法

### 1. 运行基准测试

```bash
# 进入基准测试目录
cd examples/benchmark

# 运行基准测试工具
go run benchmark_tool.go
```

### 2. 查看测试结果

运行完成后，会生成以下文件：

- `benchmark_report.md`: 详细的Markdown格式报告
- `benchmark_trends.json`: JSON格式的性能数据，用于趋势分析

### 3. 自定义测试

你可以修改 `benchmark_tool.go` 文件来添加自定义的测试场景：

```go
// 添加自定义测试场景
func (s *BenchmarkSuite) benchmarkCustomScenario() {
    result := testing.Benchmark(func(b *testing.B) {
        // 你的测试逻辑
        for i := 0; i < b.N; i++ {
            // 执行待测试的操作
        }
    })
    
    s.results = append(s.results, BenchmarkResult{
        Name: "CustomTest",
        // ... 其他字段
    })
}
```

## 输出示例

### 控制台输出
```
🚀 Sysconf 配置管理基准测试工具
==================================================

📊 开始执行基准测试...

🔧 测试配置初始化性能...
🌍 测试环境变量绑定性能...
📖 测试配置获取性能...
🔄 测试并发访问性能...
💾 测试配置文件I/O性能...
🧠 测试内存使用情况...
📚 测试大型配置性能...

================================================================================
📈 基准测试报告
================================================================================

测试名称                                      操作次数        ns/op    allocs/op     bytes/op
----------------------------------------------------------------------------------------------------
ConfigInit_基础配置                              1000       125643            8         2048
ConfigInit_环境变量配置                           500       234567           15         4096
EnvBinding_100_vars                              300       345678           25         8192
ConfigGet_简单键                                10000         1234            0            0
ConcurrentGet_8_goroutines                       5000         2345            1          128

==================================================
🎯 性能摘要
==================================================
🚀 最快操作: ConfigGet_简单键 (1234 ns/op)
🐌 最慢操作: EnvBinding_5000_vars (987654 ns/op)
🧠 平均内存使用: 2048 bytes/op

💡 优化建议:
   - 环境变量绑定较慢 (EnvBinding_5000_vars): 考虑实现前缀过滤优化
   - 配置获取内存分配较多 (ConfigGet_嵌套键): 考虑实现缓存机制
```

### 报告文件 (`benchmark_report.md`)

生成的Markdown报告包含：

- 系统信息 (Go版本、操作系统、CPU信息)
- 详细的基准测试结果表格
- 按类别分组的性能分析
- 优化建议和最佳实践

### 趋势数据 (`benchmark_trends.json`)

JSON格式的性能数据，便于：

- 长期性能趋势监控
- 性能回归检测
- 与历史数据对比
- 集成到CI/CD pipeline

## 性能基准

### 推荐性能指标

基于典型使用场景，以下是推荐的性能基准：

| 操作类型 | 推荐阈值 | 说明 |
|----------|----------|------|
| 配置初始化 | < 1ms | 包含100个环境变量的情况下 |
| 简单配置获取 | < 1μs | 第一级键值获取 |
| 嵌套配置获取 | < 5μs | 3层以内嵌套 |
| 并发读取 | > 1M ops/s | 8核心下的吞吐量 |
| 内存使用 | < 1KB | 每个配置实例 |

### 性能优化建议

1. **环境变量处理优化**:
   - 实现前缀过滤减少无效处理
   - 使用懒加载避免启动时性能损失
   - 考虑缓存机制减少重复计算

2. **配置获取优化**:
   - 实现本地缓存减少重复解析
   - 使用更细粒度的锁提高并发性能
   - 考虑预编译常用配置路径

3. **内存优化**:
   - 使用对象池减少内存分配
   - 及时清理不用的配置实例
   - 优化字符串处理减少内存拷贝

## 持续集成

可以将基准测试集成到CI/CD流程中：

```yaml
# .github/workflows/benchmark.yml
name: Benchmark
on: [push, pull_request]

jobs:
  benchmark:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - uses: actions/setup-go@v2
      with:
        go-version: 1.21
    
    - name: Run Benchmark
      run: |
        cd examples/benchmark
        go run benchmark_tool.go
        
    - name: Upload Results
      uses: actions/upload-artifact@v2
      with:
        name: benchmark-results
        path: |
          examples/benchmark/benchmark_report.md
          examples/benchmark/benchmark_trends.json
```

## 故障排除

### 常见问题

1. **测试运行时间过长**
   - 减少大型配置测试的配置项数量
   - 降低环境变量测试的变量数量
   - 调整基准测试的运行时间

2. **内存使用过高**
   - 确保测试后及时清理资源
   - 检查是否有内存泄露
   - 调整并发测试的协程数量

3. **结果不稳定**
   - 确保测试环境稳定
   - 运行多次取平均值
   - 考虑系统负载的影响

## 贡献

欢迎提交问题和改进建议！如果你有新的测试场景想法或发现性能问题，请：

1. 提交Issue描述问题
2. 创建Pull Request提供解决方案
3. 分享你的基准测试结果

## 许可证

与主项目使用相同的许可证。 